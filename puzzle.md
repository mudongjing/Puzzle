 简答的智力题及解答

# 环形轨道加油站

==一个环形轨道上有n个加油站，所有加油站的油量总和正好够车跑一圈。证明，总能找到其中一个加油站，使得初始时油箱为空的汽车从这里出发，能够顺利环行一圈回到起点。==

原文中的答案：

> 总存在一个加油站，仅用它的油就足够跑到下一个加油站（否则所有加油站的油量加起来将不够全程）。把下一个加油站的所有油都提前搬到这个加 油站来，并把油已被搬走的加油站无视掉。在剩下的加油站中继续寻找油量足以到达下个加油站的地方，不断合并加油站，直到只剩一个加油站为止。显然从这里出发就能顺利跑完全程。
>
> 另一种证明方法：先让汽车油箱里装好足够多的油，随便从哪个加油站出发试跑一圈。车每到一个加油站时，记录此时油箱里剩下的油量，然后把那个加油站的油全部装上。试跑完一圈后，检查刚才路上到哪个加油站时剩的油量最少，那么空着油箱从那里出发显然一定能跑完全程。

这里可以假设两个加油站的油量历程如果可以到达对方的位置，则可以将二者视为一个个体。类似的，如果多个加油站可以保证从一个开始能够靠着油量里程经过这几个加油站，也可以将多个加油站视为一个个体。

而一个独立的加油站，即油量里程无法到达附近的加油站，也可以视为一个个体。

那么，现在总的油量里程是覆盖环形轨道的，设想我们顺时针前进，每个个体的油量里程也向前延伸出一条里程带。如果我们无论如何不能完成这次环形轨道，则意味着个体之间延伸的里程带是出现缺口的，那么就意味着原本覆盖整条轨道的油量凭空缺失了一部分，显然不可能，因此我们总可以找到一个个体作为开头出发完成轨道环行。

--------------------------

# 红蓝棋盘

==在一个m*n的棋盘上，有k个格子里放有棋子。是否总能对所有棋子进行红蓝二染色，使得每行每列的红色棋子和蓝色棋子最多差一个？==

原文答案：

> 可以。建一个二分图G(X,Y)，其中X有m个顶点代表了棋盘的m个行，Y有n个顶点代表了棋盘的n个列。第i行第j列有棋子就在X(i) 和Y(j)之间连一条边。先找出图G里的所有环（由于是二分图，环的长度一定是偶数），把环里的边红蓝交替染色。剩下的没染色的图一定是一些树。对每棵树 递归地进行操作：去掉一个叶子节点和对应边，把剩下的树进行合法的红蓝二染色，再把刚才去掉的顶点和边加回去，给这个边适当的颜色以满足要求。

为了保证染色后对最后的结果不产生恶劣影响，则要求染色时最好是上下左右都搞一下。实际上，我们在前期染色采用的是，找矩形端点，找到这样四个点再做交替染色，无论是行还是列都没有影响，可以将这些点忽略了。

最后剩下的就是那些无法形成矩形端点的，那就更好办了，如果一个三缺一的，那么直角点的那个随意，剩余的行列交替，三都达不到的，直接交替染色。

--------------------------

# 矩阵归一

==任意给一个8*8的01矩阵，你每次只能选一个3*3或者4*4的子矩阵并把里面的元素全部取反。是否总有办法把矩阵里的所有数全部变为1？==

原文答案：

> 不能。大矩阵中有36个3*3的小矩阵和25个4*4的小矩阵，因此总共有61种可能的操作。显然，给定一个操作序列，这些操作的先后顺序 是无关紧要的；另外，在一个操作序列中使用两种或两种以上相同的操作也是无用的。因此，实质不同的操作序列只有2^61种。但8*8的01矩阵一共有 2^64种，因此不是每种情况都有办法达到目的。

----------------------------------

# 狡狐五窟

==五个洞排成一排，其中一个洞里藏有一只狐狸。每个夜晚，狐狸都会跳到一个相邻的洞里；每个白天，你都只允许检查其中一个洞。怎样才能保证狐狸最终会被抓住？==

原文答案:

> 按照2, 3, 4, 2, 3, 4的顺序检查狐狸洞可以保证抓住狐狸。为了说明这个方案是可行的，用集合F表示狐狸可能出现的位置，初始时F = {1, 2, 3, 4, 5}。如果它不在2号洞，则第二天狐狸已经跑到了F = {2, 3, 4, 5}。如果此时它不在3号洞，则第三天狐狸一定跑到了F = {1, 3, 4, 5}。如果此时它不在4号洞，则再过一晚后F = {2, 4}。如果此时它不在2号洞，则再过一天F = {3, 5}。如果此时它不在3号洞，再过一天它就一定跑到4号洞了。
>
> 方案不是唯一的，下面这些方案都是可行的：
>
> 2, 3, 4, 4, 3, 2
> 4, 3, 2, 2, 3, 4
> 4, 3, 2, 4, 3, 2

拓展以下：如果是n只狐狸，有N个洞（N>>n），同样这些狐狸每晚也会跳到附近的洞，但是如果两只狐狸会跳到同一个洞时，狐狸会互相协商，总之双方都会跳到原本附近的洞中，且洞中只有一个狐狸【这就要求，如果发生链式反应，狐狸之间一步错，就需要涉及其它很多狐狸改变既定的洞口】。如果每次只能检查n个洞口，如何逮住这些狐狸？

-----------------------

# 四马难追

==有64匹马，8条赛道，要找出最快的4匹马，最少要几次呢？【没有计时器】==

最多需要11次。

首先64匹马分8个批次比赛，得到8条相对排名结果。【此时已经有8次】

- 因为每队的后四名必然不符合，去除后剩32匹马。

8个批次的第一名再比赛【此时为第9次】。本次的后四名对应的批次全部排除，剩16匹。

- 其中此时的第一名必然是最快的（不用考虑），第四名对应的批次剩余的3个也不用考虑。于是剩下12匹。

随便挑8匹比赛【第10次】，前四名与剩下的四匹比赛【第11次】，前三名与一开始的第一名组成最快的四匹马。

---------------------------

# 两堆石子

==取石子。有两堆石子，数量各自都是随意的，两个人先后依此拿石头，两种拿法，要么在一堆里随便拿，要么在两堆里拿同样数量的石头。最后谁把石头拿完就胜利。==

这里的问题关键在于最后要么只剩一堆，要么两堆数量相同。

假如你是先手，【当然了，如果一堆是0个，或两堆数量相同，那就没必要考虑】，这里假设两堆数量不同。为了取胜，首先避免让两堆数量等同【且不为0】，但如果遇到2：1的状况你就输定了。

现在我们换个具体点的例子，一堆是3，一堆是5.

> 我们需要避免自己遇到1：2。一方面要避免给对方的结果是1+c：2+c，或1：2+c，或2：1+c
>
> 3：4$\longrightarrow $ 1:2 不行
>
> 那我们就没有其它选择了，
>
> 于是我们输了。

如果是3:6呢。直接拿一个，转化为3：5给对方，我们赢了。3：7，3：8也同样，我们都能赢。

​		4：5$\longrightarrow $ 3：5，又赢了 ，4：6$\longrightarrow $ 3：5又赢了。

4：7，我们必须把它转化为1：2或3：5，否则我们必输，可惜现在怎么也转化不了。于是又有了一个特殊的情况。这种特殊情况我们称之为奇异局势。

这个问题其实被称为**威佐夫博弈**。

我们接下来试着分析如何得出所有的奇异局势。

> 首先，局势状况我们表示为（x,y），我们发现每个奇异局势的|x-y|的值不同。
>
> - 这是当然的，如果|x-y|等于前面奇异局势的差值，那么就可以转化为那个奇异局势，那当前的局势自然也不是一个奇异的
>
> 因此，我们首先要保证下一个局势的差值不等于前面奇异局势的差值，同时对应的x,y中的值也不能与前面的奇异局势有相同的，否则一步就可以转化。
>
> 假设x<y。S是当前奇异局势中x,y数值的集合，正整数集合N+，新的集合SN=N+-S，SN中最小的数字应该就是下一个奇异局势的x，加上下一次应该具备的差值，就可以得到对应的y值。，如果y正好不在S中，那基本就成了。
>
> 例如，(1,2),(3,5),(4,7),那么下一个x应该是6，对应的y就是10，分析一下，还真是输了。

现在的问题就是，我们基本知道了怎么生成这些奇异局势，但如何根据给定的差值得出对应的奇异局势。

> 通过上面的推导，我们基本上有一个认知，集合S是不断逼近N+的，而且x和y对应集合是互斥的。
>
> 巧了，我们有一个定理：贝蒂定理
>
> - 设a和b是两个正无理数，并且$\frac{1}{a}+\frac{1}{b}=1$
>   记$P=\{[a*n],n\in N^+\},Q=\{[b*n],n\in N^+\}$ ,有$P\cap Q=\emptyset,P\cup Q=N^+$ 
>
> 我们的x,y不正好符合P和Q集合中的元素嘛，假设$x=[n*a],y=[n*b]$，如果n对应的是奇异局势的差值，且$[n*a]+n=[n*b]$，那不就是我们需要的嘛。
>
> 稍微转化一下
>
> $[n*a+n]=[n*b]\longrightarrow [(a+1)*n]=[b*n]$
>
> 因为n是随意的，则要求$a+1=b$，代入$\frac{1}{a}+\frac{1}{b}=1$ ，得到$a=\frac{\sqrt5+1}{2}$ 
>
> 于是第n个奇异局势为$([n*\frac{\sqrt5+1}{2}],[n*\frac{\sqrt5+1}{2}]+n)$ 

> 那么这个贝蒂定理是怎么回事。
>
> $P\cap Q$
>
> - 假设$k\in P\cap Q, k=[n*a]=[m*b]$ 
>
>   $k<n*a, m*b<k+1$ 
>
>   $\frac{n}{k+1}<\frac{1}{a}<\frac{n}{k}, \frac{m}{k+1}<\frac{1}{b}<\frac{m}{k}$
>
>   $\frac{m+n}{k+1}<\frac{1}{a}+\frac{1}{b}<\frac{m+n}{k}$, 其中$\frac{1}{a}+\frac{1}{b}=1$
>
>   $k<m+n<k+1$ ,m和n是正整数，矛盾了
>
> $P\cup Q$
>
> - 假设$k\in N^+, k\notin P\cup Q$ 
>
>   $[n*a]<k<[(n+1)*a], [m*b]<k<[(m+1)*b]$
>
>   有，
>
>   ​	 	$n*a<k<(n+1)*a-1$
>
>   ​		 $m*b<k<(m+1)*b-1$
>
>   整理，
>
>   ​		$\frac{n}{k} <\frac{1}{a}<\frac{n+1}{k+1}$, $\frac{m}{k} <\frac{1}{b}<\frac{m+1}{k+1}$
>
>   于是，
>
>   ​		$\frac{m+n}{k}<\frac{1}{a}+\frac{1}{b}<\frac{m+n+2}{k+1}$
>
>   得到，
>
>   ​		$m+n<k<k+1<m+n+2$， 同样的，应该是整数的情况下，这是矛盾的。

# 一堆石子

==**斐波那契博弈(Fibonacci Nim)**==

==有一堆个数为n(n>=2)的石子，游戏双方轮流取石子，规则如下：==

==1)先手不能在第一次把所有的石子取完，至少取1颗；==

==2)之后每次可以取的石子数至少为1，至多为对手刚取的石子数的2倍。==

==约定取走最后一个石子的人为赢家，求必败态==

> 结论：当n为Fibonacci数的时候，必败

正经的答案基本上提及**齐肯多夫定理**（任何正整数都可以表示成若干个不连续的斐波那契数（不包括第一个斐波那契数）之和【归纳法试一试就可以得到】。

> 第n个Fibonacci数为$\varphi_n$ , 假设小于$\varphi_n$ 的数符合该定理，那么$\varphi_n<x<\varphi_{n+1}$, 那么$x=\varphi_n+(x-\varphi_n)$ ,$\varphi_n<x<\varphi_n+\varphi_{n-1}$ 
>
> $x-\varphi_n<\varphi_{n-1}$ ,那么$x-\varphi_n$符合定理等于不连续的Fibonacci数之和，且必定不包含$\varphi_{n-1}$ ,于是仍旧符合定理

为了方便，下面的Fibonacci数简称为φ数。

我们还是来简单的分析一下：

> 首先，我们 不能拿超过$\frac{n}{3}$ 的石子。
>
> 那么，如果是3，很明显，我们不得不拿一个，然后输了
>
> 如果是4，我们拿一个，剩下3，让对手输
>
> 如果是5，我们还是只能拿1个，于是4的情况给对手了，我们又输了
>
> 现在，我们就发现了3，5是φ数。
>
> 接下来的6可以转化为5，赢了。      如果是7 的话，此时我们终于能够拿2了，转化为5，又赢了。
>
> 如果是8，我们最多能拿2，而6和7又是我们的死局，我们必输。
>
> 类似的，9到11，我们都可以赢.对于12，我们不能转化为8，看似必输，但是，如果我们拿1，对方也不能转化为8，我们又赢了。
>
> 关键就在12里面，为什么乍一看必输的情况，但实际没问题呢。
>
> - 12=8+4，我们拿不到4，只能先吃掉现有的4，而前面的例子告诉我们，4可以被我们先吃完，于是8就留给了对手，于是我们赢了
>
> 由此，如果是8+5，我们就歇菜了。同理，13开始，13+1，...13+5,...+13+7，都是可以赢的，13+8输了。
>
> 于是，我们归纳出，φ数是必输的局面。
>
> 【如果是8+5+3呢，此时我们就可以拿走3，于是对方就输了，因为$\frac{8+5+3}{3}>3$ 】
>
> 为什么呢，不连续的φ 数至少相差2倍，$a_{n+1}=a_n+a_{n-1}>2a_{n-1}$ 
>
> - 如果不是φ数，则可以表示为$a_n+a_{n-1}+\dots +a_1,其中a_n>a_{n-1}>\dots>a_1$ ,且$\{a_i|a_i属于\ \varphi数 \}$ ，且这些φ数是不连续的φ数，
> - 那我们拿走$a_1$ ,对手是无法完全拿走$a_2$ ,他必然输

# 几堆石子【这个问题稍微复杂一些】

==目前有任意堆石子，每堆石子个数也是任意的，双方轮流从中取出石子，规则如下：==
==1)每一步应取走至少一枚石子；==

==2)每一步只能从某一堆中取走部分或全部石子；==

==如果谁取到最后一枚石子就胜。==

==问先手必败的局面==

这个问题称为尼姆博弈。

- 我们先考虑两堆的情况。首先，1：1我们必输，如果我们面对1：n（n>1)的情况，必赢。如果每堆的石子均多于2，我们必不能把一堆拿完或剩一个。如果剩2，对方是不敢拿这一堆的，对方会让另一堆剩2，我们必输。现在我们发现，如果局面是2：n（n>2），先手也是必赢的。

  现在，我们可以将两堆的情况表示为$(x,·),其中x<·$ .  我们已经分析$(1,·)必赢和(2,·)必赢$ 。那么我们不妨猜一下$(3,·)、(4,·)、\dots $又会对应什么情况。

  对于$(3,·)$,3是不能动的，只能将·减为3，对方就不得不将必胜的局面留给我们。$(4,·)$类似。

  因此，$(n,·)$是两堆情况下的先手必胜局面。换句话说，当两堆数量相同，则先手必输。

- 现在考虑3堆的情况下，如果存在两堆数量相同，则先手必赢，也就是我们需要避免在有3个非空堆的情况下为对方留下至少两个相等的堆，如果只留下两个不相等的堆，我们一样必输。

  于是，如果存在两个堆相同，我们赢了。如果三堆互不相等，则我们需要保持3个非空不等的堆，同样的，对方也不得不遵循这一方案。

  上述的分析，我们知道，当我们面对的是1：2：3,我们必输，进一步的，如果局面为$x:y:z$，其中$x,y  \leq 3,且x\neq y,z>3$   此时我们必赢。那么我们又多了一个限制，不让对方的局面包含对应的x：y.

  比如局面是3：4：5，我们别无选择，只能得到1：4：5，，那么对方同样别无选择，我们必赢，2：4：5也同样，由此得到1：4：5是必输的局面。

  那么1：5：6呢，可以转化为1：4：5,我们赢了，1：5：7同样必赢。

  如果是1：6：7，我们只有转化为4或5的选择，必输，如果是1：6：8，则转化为1：6：7，我们必赢。

  那么1：7：8，必赢，1：7：9同样必赢。

  1：8：9，必输，1：8：10可以转化为1：8：9，必赢。

  1：9：10，必赢，1：9：11同样必赢。

  

  于是有1：2k：2k+1必输，而对于局面1：2k+1：n，其中n>2k+1，我们必赢。

  反之，当m>1时，m：2k：2k+1，我们必赢。

  那对于m：2k：n，其中n>2k+1,又是什么情况呢？我们会发现这样下去，问题不断地延伸，复杂度不断增加，到这里，上述的分析对于实际的问题解决是没有太大的帮助的，只是带着读者更加熟悉问题，以及明白该问题的复杂程度。

  ----------------

  这个问题其实是比较复杂的，问题的结论是每堆的数量表示为二进制数，再异或，结果为0，则必败。

  而这个结论是一篇专门的数学论文给出的，因此读者自己搞不出来也不必难过，因为确实不简单，论文[原文]([Nim, A Game with a Complete Mathematical Theory (jstor.org)](https://www.jstor.org/stable/pdf/1967631.pdf))可自行查看,更厉害的是，那时是1901年，还没有计算机，二进制也没那么普遍使用，异或运算更是无从谈起，因此论文中的一些表述与现在的描述是有所区别的。

  原文给出了一些必败局面的示例，

  ![](https://mudongjing.github.io/gallery/puzzle/8.png)

  我们现在自己试着分析一遍。

  - 首先，在堆为两个的情况时，n：n时，二者数量相同，对手可采用跟随策略，即我在其中一堆拿了多少的石子，对手接下来也会在另一堆中拿相同数量的石子，以保证先手面对的局面都是n：n的情况。

  - 那么，对于3堆的情况，我们是否可以延续这种跟随策略，不同的是，我们可以将现有的堆看作广义上的两堆，即我当前拿石子的那堆是一堆，而其它所有堆是另一堆，我在这一堆拿了石子，对手必然要到广义的另一堆中拿石子【如果对手也在我那堆操作，岂不是说明我也可以将局面变成对手必败的局面，显然与假设的先手必败局面矛盾】

    - 既然是跟随策略，那么必然是保证局面维持着某种性质的平衡。局面为a：b：c，可视为广义的两堆[a]：[b, c]

    - 我们假设这种性质的量表示为g(n)，两堆的情况下，$g(n)=g(n)$，那么3堆时则有$g(a)=g(b)+g(c)$。假如c为0，即转化为两堆的情况，显然$a=b$时，是必败局面，则有$g(a)=g(a)+g(0)$ ,另外我们已经有$g(a)=g(a)$，则$g(0)$ 可视为0。

      进一步的，对于两堆时，1：0的情况，我们知道，将1减去1，就可以恢复平衡，则可以视为$g(1)=g(0)+1=1$

    - 现在我们回想一下，之前我们得出$1:2k:2k+1$是必败的局面，于是有$g(2k+1)=g(1)+g(2k)$

    - $g(n)$这种性质对任意数字都是独立的，不受其它数字的影响，就如上述的式子，可以随便写成$g(1)=g(2k)+g(2k+1)$或$g(2k)=g(1)+g(2k+1)$ ,只要满足必败局面，则任意的广义的两堆都是该性质平衡的。特殊的，我们可以得出$g(a)+g(a)=g(0)=0$，于是我们知道当存在两个相同值，则可以相互抵消。

      举个例子，上述的必败局面中，有2：9：11，另外$g(9)=g(1)+g(8),g(11)=g(1)+g(10)$,那么$g(2)=g(9)+g(11)=g(1)+g(8)+g(1)+g(10)=g(8)+g(10)$,对应到2：8：10，仍然是一个必败局面，符合性质平衡。

    - 因此，我们可以明白，一个数字的性质的量如果可以拆分成另外两个较小的数字的性质的量之和，那么在于其它数字进行性质相加时，可以转化为更小的两个数字的性质和，同样的，如果两个数字的性质和正好可以表示为一个数字性质和，那么堆的数量又可以减小。

      由此，一步步操作，堆的数量减小，或者石子数减小，最终可以达到一个较为简单的情况。

    - 但，是不是任何数字都可以转化为两个较小的数字的性质和呢？显然不是的。

      比如在上述的示例中，我们发现2的次幂找不到合适的表示，我们来分析一下。

      首先，对于6，可以表示为$g(6)=g(2)+g(4)$, 

      8=2+6=4+4【如果是奇数相加，都会转化为对应的偶数相加】，$g(4)+g(4)=0, g(2)+g(6)=g(2)+g(2)+g(4)=g(4)$,都无法做合适的表示，因为相加的两个数都可以拆分出重复的值，导致抵消，那么$g(6)+g(4),g(6)+g(6)$也不行。

      于是$g(8)$是没有我们期望的拆分表示，并且前面的2,4也是没有的。

      那么对于16呢。首先，对于10，可以表示为$g(10)=g(2)+g(8)$ ,因为此时，2，8都是无法拆分的，因此不存在抵消，导致2+8=10，就可以直接转化为对应的性质和，同样的，12=4+8，也可以表示为$g(12)=g(4)+g(8)$ ,14=6+8=2+4+8,不存在抵消，则有$g(14)=g(6)+g(8)$ .

      那么对于16，16=1+2+4+8+1，无论怎么搞，都会出现重复，因此，同样是无法得到期望的表示。

      类似的，2的次幂都是无法进行拆分的。而前面的介绍也顺便说明了普通的偶数是可以表示为对应的2 的次幂的和，于是表示为对应的性质和，结合$g(2k+1)=g(1)+g(2k)$,任意的奇数也可以表示为对应的2的次幂的和。

    - 现在，我们就已经发现了与二进制的关系了，所谓的重复就抵消，也是对应了异或操作。


# 重复数

==计算机问题，给定一个整数数组，已知==

==(1) 一个数重复了奇数次，而其它数都重复了偶数次，问找到那个奇数次的数==

​	这个问题，就是简单的异或方法，一个整数a，a\^a=0，而a\^0=a，因此只要全部的数一起异或一次即可

==(2) 如果是两个数各重复了奇数次，其它数都是重复偶数次。找出两个奇数次的数==

​	假设两个数分别是a，b，异或后，得到c=a^b，此时c不为0，其中二进制上为1的位就是a和b不相同的地方，随便挑一个位置，再对数组异或，只不过要求仅和该位置为1的数异或（或者仅和为0的数异或），总之，将得到a或b，再与c异或，就得到两个对应的数、

> 假设取整数二进制最右侧的1，
>
> c & (~c +1)

# 约瑟夫问题

==据说著名犹太历史学家Josephus有过以下故事：在罗马人占领乔塔帕特后，39个==
==犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓==
==到，于是决定了一种自杀方式，41个人排成一个圆圈，由第1个人开始报数，报数到3==
==的人就自杀，然后再由下一个人重新报 1，报数到 3 的人再自杀，这样依次下去，直==
==到剩下最后一个人时，那个人可以自由选择自己的命运。这就是著名的约瑟夫问题。==
==现在请用单向环形链表描述该结构并呈现整个自杀过程。==

==输入：一个环形单向链表的头节点head和报数的值m。==
==返回：最后生存下来的节点，且这个节点自己组成环形单向链表，其他节点都删==
==掉。==
==进阶问题：如果链表节点数为N，想在时间复杂度为O（N）时完成原问题的要==
==求，该怎么实现？==

​													==———— 摘自《程序员代码面试指南——IT名企算法与数据结构》==

这里问题的本质是，如何在给定人数和报数确定一开始哪个编号的人是最后一个自杀的人。或者返过来理解，现在由一个幸存者，在知道上述两个变量后，如何反过来推断他最初的编号。原问题是通过指定的删除方法获得存活的节点，而我们的高效算法则是通过反向推出当前或者的节点，上一次是什么编号。

> 节点自己报的数n，循环数是m，那么对应的逻辑编号就是$i=(n-1)\,\%\,m +1$。
>
> 那么当前的逻辑编号对应的节点是上次存活下来的节点，并且是从自杀节点的下一个节点开始报数，如何确定当前逻辑编号和上一轮报数的关系？
>
> 
>
> 上一轮自杀的节点编号为s，那么s+1往后的节点组成从1开始的新一轮节点，而s-1向前则是组成新一轮的末尾部分。
> $$
> {编号}_{前}=({编号}_{后}+编号_{上轮自杀节点}\,-1)\,\% m \,+\, 1
> $$
> 上述公式，就是比如，当前编号是1，那么必然是因为上一轮他恰好是在自杀节点的下一处，同理，其它 节点，也是在自杀节点之后，因此，可以将自己的编号拼接在其后，另外，如果是在自杀节点之前的节点，则需要

# 子数组累加和$\leq$k的最大长度

==给定一个无序数组arr，其中元素可正、可负、可0。给定一个整数k，求arr所有的==
==子数组中累加和小于或等于k的最长子数组长度。==
==例如：arr=[3，-2，-4，0，6]，k=-2，相加和小于或等于-2的最长子数组为==
=={3，-2，-4，0}，所以结果返回4。==

​                                 ==———— 摘自《程序员代码面试指南——IT名企算法与数据结构》==

原数组是a[]。准备两个与原数组等容量的数组，sum[], end[]，两个数组分别对应以a[i]为开头的子数组最小的累加和，对应位置最小和的结束位置。

上述的数组就可以从右向左一次计算各个数值。

做完准备工作后，就可以隐性地利用窗口思维，从左向右扩展子数组的范围，比如，从0位置开始，利用完成的数组可以知道向后最小和的一段范围，如果可以，在考虑下一个范围，如果下一个范围的最小和加上之后不满足要求，那么就没必要继续，可以让窗口左边界右移一位。

# 完美洗牌

==给定一个长度为偶数的数组arr，长度记为2×N。前N个为左部分，后N个为右部==
==分。arr就可以表示为{L1，L2，..，Ln，R1，R2，..，Rn}，请将数组调整成{R1，==
==L1，R2，L2，..，Rn，Ln}的样子。==

==进阶问题：给定一个数组arr，请将数组调整为依次相邻的数字总是先＜=、再＞= 
的关系，并交替下去。比如数组中有五个数字，调整成{a，b，c，d，e}，使之满足a==
==＜=b＞=c＜=d＞=e==

​											 ==———— 摘自《程序员代码面试指南——IT名企算法与数据结构》==

使用的思想也很简单，就是数组已经分好了前后两个部分，我们的目标也是将指定位置的数值放在指定的位置，而上面的完美洗牌目标也是有着这样明确的下标对应。就可以把一个位置的数据放到指定的位置，对应位置的数据在放到它对应的位置，就这样一个个挤来挤去，把每个数据挤到自己应该的位置上。

但是，这种方法存在一个问题就是，我们无法从一个位置一直挤完最后一个数据，因为会发生操作中断的状况，这种中断是完成了某一个部分的内部操作，到这里，如果我们代码会回到初始位置，如果没有一个公式计算的话，则需要遍历查询未变化的位置。

可惜的是，有这样一个公式，但使用范围有限，

> 如果数组的长度是$3^k-1$，那么对应的几个出发位置就是$1,\, ...,\, 3^{k-1}$。

对于其它偶数的数组，只需要将原数组拆分成若干个符合对应大小的数组，即可。

> 这种操作，就是在数组内部做局部的调换。

# 正则表达式实现

==给定字符串str，其中绝对不含有字符'.'和'*'。再给定字符串exp，其中可以含
有'.'或'*'，'*'字符不能是exp的首字符，并且任意两个'*'字符不相邻。exp中的'.'代表任==
==何一个字符，exp中的'*'表示'*'的前一个字符可以有0个或者多个。请写一个函数，判==
==断str是否能被exp匹配。==

 						==———— 摘自《程序员代码面试指南——IT名企算法与数据结构》==

 

# 打气球



# 旋变字符串



# LFU缓存替换



# 加油站良好出发点



# 二叉树中符合搜索二叉树条件的最大拓扑结构



# 错误节点

